apiVersion: v1
kind: ConfigMap
metadata:
  name: forwarder-logstash-ruby
  namespace: openshift-logging
  labels:
    app: forwarder
    appVersion: logstash
    app.kubernetes.io/component: forwarderLogstash
    app.kubernetes.io/instance: forwarderLogstash
data:
  format-message.rb: |
    def recursive_format(event, field)
      #Reconstruct path
      path = ""
      field.each do |f|
        path += "["+f+"]"
      end

      content = event.get(path)

      #Remove key/value to replace it
      event.remove(path)

      # Remove beginning and ending brackets
      content.sub!( /^\{/ , '' )
      content.sub!( /\}$/ , '' )

      # Replace special characters between '[]'.
      if content.match(/\[.*\]/)
        content[/\[(.*)\]/m, 1] = content.slice(/\[(.*)\]/m, 1).gsub(', ', '# ')
      end

      # Replace special characters between '{}'.
      if content.match(/\{.*\}/)
        content[/\{(.*)\}/m, 1] = content.slice(/\{(.*)\}/m, 1).gsub(', ', '# ')
        content[/\{(.*)\}/m, 1] = content.slice(/\{(.*)\}/m, 1).gsub('=>', '#>')
      end

      #Loop through each sub-key/value
      content.split(", ").each do |subfield|
        # Put back all ', '
        unless subfield.empty?
          subfield.gsub!( '# ', ', ')
        end

        # Split key and value
        key = subfield.split("=>")[0]

        # Get value if exist, and put back remaining '=>'
        if subfield.split("=>").length() == 2
          value = subfield.split("=>")[1]
          value.gsub!('#>', '=>')
        else
          value = ""
        end

        # Path with key
        subpath = path+"["+key+"]"

        # If value is an array
        if value[0] == "[" && value[-1] == "]"
          value.sub!(/^\[/, '').sub!(/\]$/,'')
          values = value.split(',')
          event.set(subpath, values)

        # If value is not an array
        else
          event.set(subpath, value)
          # If value contain sub-key/value
          if value[0] == "{" && value[-1] == "}"
            field.push(key)
            recursive_format(event, field)
            field.pop()
          end
        end

      end
    end
    
    def filter(event)
      message = event.get("[message]")

      # Sometimes, some exception are not formated
      unless message.match( /.* .* (.* .*) - - - .*/ )
        return [event]
      end

      event.set("[OriginalMessage]", message)

      #Error when using @timestamp
      message.sub!('@timestamp', 'timestamp')

      # Extract collector pod name
      message[/(.* - - - ).*/, 1] = "collector:" + message[/.* .* (.* .*) - - - .*/, 1] + "\t"

      # "field:value" to "field=>value"
      fields = message.split("\t")
      fields.each do |field|
        field.replace( field[/(.*?):.*/, 1] + '=>' + field[/.*?:(.*)/, 1] )
      end
      message = fields.join(", ")

      # Remove special characters
      message.gsub!( '"' , '' )
      message.gsub!( '\\' , '"' )

      if message.match( /systemd.*status: / )
        puts "###Erreur possible: " + message + "##"
        return [event]
      end

      # Replace message
      event.remove("[message]")
      event.set("[message]", message)

      begin
        recursive_format(event, ["message"])
      rescue => e
        event.set("[message]", event.get["OriginalMessage"])
      end

      event.remove("[OriginalMessage]")
      
      return [event]
    end